<!-- <!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Inverted Camera</title>
  <style>
    body {
      margin: 0;
      background: black;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
    }
    video {
      transform: scaleX(-1); /* Mirror horizontally if you want */
      filter: invert(1);
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
  </style>
</head>
<body>
  <video id="camera" autoplay playsinline></video>

  <script>
    const video = document.getElementById('camera');

    // Ask for camera access
    navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" } })
      .then(stream => {
        video.srcObject = stream;
      })
      .catch(err => {
        alert("Camera access denied: " + err);
      });
  </script>
</body> -->

</html>

<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Web Scanner (OpenCV.js)</title>
  <style>
    body { margin:0; font-family: sans-serif; display:flex; flex-direction:column; height:100vh; }
    #video { width:100%; height:45vh; object-fit:cover; background:black; }
    #output, #preview { width:100%; height:45vh; object-fit:contain; background:#111; }
    .controls { display:flex; gap:8px; padding:8px; justify-content:center; }
    button { padding:10px 16px; font-size:16px; }
  </style>
</head>
<body>
  <video id="video" autoplay playsinline></video>
  <canvas id="hiddenCanvas" style="display:none"></canvas>
  <img id="preview" alt="scanned result" />
  <div class="controls">
    <button id="captureBtn">Capture & Scan</button>
    <button id="downloadBtn" disabled>Download PNG</button>
  </div>

  <!-- OpenCV.js from official CDN (wasm build). When serving locally, ensure CORS/HTTPS. -->
  <script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady()" ></script>

  <script>
  const video = document.getElementById('video');
  const hiddenCanvas = document.getElementById('hiddenCanvas');
  const preview = document.getElementById('preview');
  const captureBtn = document.getElementById('captureBtn');
  const downloadBtn = document.getElementById('downloadBtn');

  // Start camera
  async function startCamera(){
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
      video.srcObject = stream;
      await video.play();
    } catch (e) {
      alert('Camera access failed: ' + e);
    }
  }

  // called after opencv.js loaded
  function onOpenCvReady() {
    console.log('OpenCV.js loaded');
    startCamera();
  }

  // Utility: download an image blob
  function downloadBlob(blob, filename) {
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename;
    document.body.appendChild(a); a.click();
    a.remove(); URL.revokeObjectURL(url);
  }

  captureBtn.addEventListener('click', () => {
    // draw video frame to canvas
    hiddenCanvas.width = video.videoWidth;
    hiddenCanvas.height = video.videoHeight;
    const ctx = hiddenCanvas.getContext('2d');
    ctx.drawImage(video, 0, 0, hiddenCanvas.width, hiddenCanvas.height);

    // run OpenCV processing (edge detect + warp)
    try {
      const src = cv.imread(hiddenCanvas); // mat from canvas
      const dst = new cv.Mat();
      const gray = new cv.Mat();
      const blurred = new cv.Mat();
      const edges = new cv.Mat();
      const contours = new cv.MatVector();
      const hierarchy = new cv.Mat();

      // convert to gray, blur, Canny
      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
      cv.GaussianBlur(gray, blurred, new cv.Size(5,5), 0);
      cv.Canny(blurred, edges, 75, 200);

      // find contours, choose the largest quadrilateral
      cv.findContours(edges, contours, hierarchy, cv.RETR_LIST, cv.CHAIN_APPROX_SIMPLE);
      let maxArea = 0;
      let pageContour = null;
      for (let i=0; i<contours.size(); i++){
        const cnt = contours.get(i);
        const peri = cv.arcLength(cnt, true);
        const approx = new cv.Mat();
        cv.approxPolyDP(cnt, approx, 0.02 * peri, true);
        if (approx.rows === 4) {
          const area = cv.contourArea(approx);
          if (area > maxArea) {
            maxArea = area;
            pageContour = approx.clone(); // keep copy
          }
        }
        approx.delete(); cnt.delete();
      }

      if (pageContour) {
        // get corner points and order them (tl,tr,br,bl)
        const pts = [];
        for (let i=0;i<4;i++){
          pts.push({x: pageContour.intPtr(i,0)[0], y: pageContour.intPtr(i,0)[1]});
        }
        // simple ordering by sum/diff
        pts.sort((a,b)=> (a.x+a.y) - (b.x+b.y)); // tl is smallest sum
        const tl = pts[0];
        const br = pts[3];
        // remaining two: determine by x coordinate
        const middle = [pts[1], pts[2]].sort((a,b)=> a.x - b.x);
        const tr = middle[1];
        const bl = middle[0];

        // compute width/height for destination
        const widthA = Math.hypot(br.x - bl.x, br.y - bl.y);
        const widthB = Math.hypot(tr.x - tl.x, tr.y - tl.y);
        const maxW = Math.max(Math.round(widthA), Math.round(widthB));
        const heightA = Math.hypot(tr.x - br.x, tr.y - br.y);
        const heightB = Math.hypot(tl.x - bl.x, tl.y - bl.y);
        const maxH = Math.max(Math.round(heightA), Math.round(heightB));

        // source and dest points
        const srcTri = cv.matFromArray(4,1,cv.CV_32FC2, [tl.x,tl.y, tr.x,tr.y, br.x,br.y, bl.x,bl.y]);
        const dstTri = cv.matFromArray(4,1,cv.CV_32FC2, [0,0, maxW-1,0, maxW-1,maxH-1, 0,maxH-1]);

        const M = cv.getPerspectiveTransform(srcTri, dstTri);
        const warped = new cv.Mat();
        cv.warpPerspective(src, warped, M, new cv.Size(maxW, maxH), cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());

        // optional: convert to white background, increase contrast
        cv.cvtColor(warped, dst, cv.COLOR_RGBA2RGB);
        // show result in preview (use canvas to convert)
        const outCanvas = document.createElement('canvas');
        outCanvas.width = dst.cols; outCanvas.height = dst.rows;
        cv.imshow(outCanvas, dst);
        preview.src = outCanvas.toDataURL('image/png');
        downloadBtn.disabled = false;

        // cleanup
        warped.delete(); srcTri.delete(); dstTri.delete(); M.delete();
      } else {
        alert('Document edges not found â€” try better lighting or hold steady.');
      }

      // free mats
      src.delete(); dst.delete(); gray.delete(); blurred.delete(); edges.delete();
      contours.delete(); hierarchy.delete();
      if (pageContour) pageContour.delete();
    } catch (err) {
      console.error(err);
      alert('Processing failed: ' + err);
    }
  });

  downloadBtn.addEventListener('click', () => {
    // convert preview dataURL to blob and download
    fetch(preview.src)
      .then(res => res.blob())
      .then(blob => downloadBlob(blob, 'scan.png'));
  });
  </script>
</body>
</html>
